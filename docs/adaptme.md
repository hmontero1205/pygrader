# Course Adaptation

`pygrader` is a generic framework intended to be forked and implemented on a per-course basis.
Here's how you can start implementing your own grading scripts.

## Creating your first assignment

Most basically, all that's required for an assignment is a top-level directory which contains
a file `grader.py`, where this file defines a `GRADER` class that inherits from the common
`HW` base class. The only limitation is that the directory name cannot be suffixed with
`_common`, as this naming is reserved for your own course-specific common directory, should
you need a place to house common resources for your scripts (e.g. `myclass_common`). Once
you've created this directory, `pygrader` scripts will automatically be able to identify it
as an assignment.

To assist with this, there is a provided `gen_assignment.sh` script at the top-level, which is
used as follows:
```
./gen_assignment.sh <assignment name> [org/repo to clone]
```

The first argument is the name of your assignment (hw2, exam1, etc.), and the second allows
you to optionally specify a base repo to be cloned on setup for this assignment. 

This script creates a directory called `<assignment name>` which looks like this:

```
.
├── grader.py
├── rubric.json
└── setup
```

As noted, `grader.py` is required for every assignment, and is generated by 
`gen_assignment.sh` to be a starting point. `rubric.json` contains the rubric for the
assignment (see the general [README](./README.md) for more details), but doesn't strictly
need to be named or located as `gen_assignment.sh` does it—this file is only referenced
from your `grader.py`, so you're welcome to tweak this as you see fit. Finally, `setup`
is a script that is executed by `hw_setup.py` (again, see the [README](./README.md))
to initially set things up for the assignment before grading. This may be any kind of
executable (Python script, Bash script, etc.), and is generally used for cloning a repo
or pulling submissions in some way. Note that this will always be executed from
`~/.grade/<assignment name>`, and that arguments can be passed through `hw_setup.py`.
`gen_assignment.sh` generates it with some basic Python logic for cloning your repo of
choice if specified, or otherwise as an empty executable file. You may remove it if no
setup is required for the assignment.

From here, you may begin implementing your grading logic in `grader.py`! The demo
assignment's `grader.py` is available for reference.

## README

Likely, you'll want your own class-specific README for instructional staff to reference
while grading, perhaps specifying arguments to pass to `hw_setup.py` or any additional
dependency installation. This can just be placed at the top-level of your repo (GitHub
will default to it over the one in `docs/`)—the recommended approach would be to copy
ours from `docs/` as a starting point and modify from there.

## Modifying the broader repo

It's recommended that you try to avoid modifying the generic infrastructure as much as
possible (i.e. anything in `common/`, `grade.py`, etc.), so as to limit conflicts in
any future rebases—`pygrader` is structured to enable the separation of class-specific
resources as much as possible. Aside from the described interpretation of top-level
directories (anything that isn't `common/` or `*_common/` is treated as an assignment),
there isn't any issue with creating new files and directories as seen fit.

Additionally, feel free to remove any/all of the following from the top-level of your
repo if/when no longer needed by the maintainers:
```
gen_assignment.sh
*.in
demo/
docs/
```

These are all things that pertain to `pygrader` as a generic infrastructure, but are
unnecessary once specific assignment scripts are fleshed out.
